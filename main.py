import os
from datetime import datetime
from flask import Flask, render_template, request, send_from_directory, Response, jsonify
import io
import logging
import fitz  # PyMuPDF
import google.generativeai as genai
from pdf2image import convert_from_path
import pytesseract
import subprocess
from google.cloud import texttospeech  # Google TTS library

# Initialize Flask
app = Flask(__name__)
UPLOAD_FOLDER = 'uploads'
ALLOWED_EXTENSIONS = {'pdf', 'wav'}
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
os.makedirs(UPLOAD_FOLDER, exist_ok=True)

# Configure API
genai.configure(api_key="AIzaSyD1hQZGSUccjECeQ4kj5gtvlxXv10T4gko")

# Google Cloud TTS Client Setup
tts_client = texttospeech.TextToSpeechClient()

# Logging
logging.basicConfig(level=logging.INFO)

# Helpers
def allowed_file(filename, exts):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in exts

def extract_text_from_pdf(pdf_path):
    doc = fitz.open(pdf_path)
    text = ""
    for i, page in enumerate(doc):
        page_text = page.get_text()
        logging.info(f"Page {i + 1}: Extracted {len(page_text)} characters.")
        text += page_text

    if not text.strip():
        logging.warning("No selectable text found in PDF. Attempting OCR...")

        try:
            images = convert_from_path(pdf_path)
            for i, img in enumerate(images):
                ocr_text = pytesseract.image_to_string(img)
                logging.info(f"OCR Page {i + 1}: Extracted {len(ocr_text)} characters.")
                text += ocr_text
        except Exception as e:
            logging.error(f"OCR failed: {e}")

    logging.info(f"Final extracted text length: {len(text)}")
    return text

def summarize_book(book_text):
    logging.info("Summarizing the book...")
    model = genai.GenerativeModel('gemini-1.5-pro-latest')
    if not book_text.strip():
        logging.warning("Book text is empty.")
        return "No content extracted from the PDF to summarize."
    response = model.generate_content([ 
        {"text": "Summarize the following text briefly:"},
        {"text": book_text[:10000]}
    ])
    logging.info("Summary generated successfully.")
    return response.text

def process_query_with_llm(book_summary, audio_path):
    logging.info(f"Processing audio file with LLM: {audio_path}")
    with io.open(audio_path, 'rb') as audio_file:
        audio_data = audio_file.read()

    prompt = """
    You are a helpful assistant. Use the summary of the uploaded book and answer the user's audio question.
    """

    model = genai.GenerativeModel('gemini-1.5-pro-latest')
    response = model.generate_content([
        {"text": prompt},
        {"text": book_summary},
        {
            "inline_data": {
                "mime_type": "audio/wav",
                "data": audio_data
            }
        }
    ])

    logging.info("Response generated by LLM.")
    return response.text

def extract_text_with_poppler(pdf_path):
    try:
        output_text = subprocess.check_output(['pdftotext', pdf_path, '-']).decode('utf-8')
        return output_text
    except subprocess.CalledProcessError as e:
        logging.error(f"Error extracting text: {e}")
        return ""

# Function to convert text to speech
def text_to_speech(response_text):
    input_text = texttospeech.SynthesisInput(text=response_text)

    voice = texttospeech.VoiceSelectionParams(
        language_code="en-US",
        ssml_gender=texttospeech.SsmlVoiceGender.NEUTRAL
    )

    audio_config = texttospeech.AudioConfig(
        audio_encoding=texttospeech.AudioEncoding.MP3
    )

    # Synthesize the speech
    response = tts_client.synthesize_speech(
        request={"input": input_text, "voice": voice, "audio_config": audio_config}
    )

    return response.audio_content

@app.route('/')
def index():
   # files = [f for f in os.listdir(UPLOAD_FOLDER) if allowed_file(f, {'pdf', 'txt'})]
    files = [f for f in os.listdir(UPLOAD_FOLDER)]
    logging.info(f"Serving index with files: {files}")
    return render_template('index.html', files=files)

@app.route('/upload_pdf', methods=['POST'])
def upload_pdf():
    logging.info("Received PDF upload request.")
    if 'pdf_file' not in request.files:
        logging.error("No file part in request.")
        return "No file part", 400

    file = request.files['pdf_file']
    if file and allowed_file(file.filename, {'pdf'}):
        filename = datetime.now().strftime("%Y%m%d-%H%M%S") + '.pdf'
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
        file.save(file_path)
        logging.info(f"PDF saved as: {file_path}")
        return "PDF uploaded successfully", 200

    logging.error("Invalid file type for PDF.")
    return "Invalid file type", 400

@app.route('/upload', methods=['POST'])
def upload_audio():
    logging.info("Received audio upload request.")
    if 'audio_data' not in request.files:
        logging.error("No audio file in request.")
        return "No audio file", 400

    file = request.files['audio_data']
    if allowed_file(file.filename, {'wav'}):
        audio_filename = datetime.now().strftime("%Y%m%d-%H%M%S") + '.wav'
        audio_path = os.path.join(app.config['UPLOAD_FOLDER'], audio_filename)
        file.save(audio_path)
        logging.info(f"Audio saved as: {audio_path}")

        # Find the most recent PDF
        pdf_files = sorted([f for f in os.listdir(UPLOAD_FOLDER) if f.endswith('.pdf')], reverse=True)
        if not pdf_files:
            logging.warning("No PDF found to process with audio.")
            return "No PDF uploaded to query", 400

        latest_pdf = os.path.join(UPLOAD_FOLDER, pdf_files[0])
        logging.info(f"Using latest PDF: {latest_pdf}")

        # Extract text using Poppler
        book_text = extract_text_with_poppler(latest_pdf)
        if not book_text:
            logging.warning("Poppler extraction failed, falling back to PyMuPDF...")
            book_text = extract_text_from_pdf(latest_pdf)
        
        book_summary = summarize_book(book_text)

        try:
            response_text = process_query_with_llm(book_summary, audio_path)

            # Save response text to a text file
           # Save response text to a text file
            response_txt_path = audio_path.replace('.wav', '.txt')
            with open(response_txt_path, 'w') as f:
                f.write(response_text)
            logging.info(f"Response saved to: {response_txt_path}")

            # Convert response text to speech and save as WAV
            audio_output = text_to_speech(response_text)

            response_wav_path = audio_path.replace('.wav', '_response.wav')
            with open(response_wav_path, 'wb') as out:
                out.write(audio_output)
            logging.info(f"Response audio saved to: {response_wav_path}")

# Return the text response (keep API simple)
            return jsonify({"text_response": response_text}), 200


        except Exception as e:
            logging.error(f"Error processing audio: {e}", exc_info=True)
            return "Processing failed", 500

    logging.error("Invalid audio file.")
    return "Invalid file", 400


@app.route('/uploads/<filename>')
def uploaded_file(filename):
    logging.info(f"Sending file: {filename}")
    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)

if __name__ == '__main__':
    logging.info("Starting Flask app...")
    app.run(debug=True)
